<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[论文阅读]Lustre: A Scalable, High-Performance File System</title>
    <url>/2021/03/06/Lustre%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Lustre</p>
<span id="more"></span>

<p>MDSs: Metadata Servers         元数据服务器</p>
<p>OST: Object Storage Targets   对象存储目标</p>
<p>OBDs: Object-Based Disks       基于对象的磁盘</p>
<p>OSDs: Object Storage Devices</p>
<p> Lustre treats files as objects that are located through metadata Servers (MDSs). </p>
<p>所有的文件都被视为对象，并且通过MDSs来定位。</p>
<p> the Lustre file system has a unique <strong>inode</strong> for every regular file, directory, symbolic link, and special file. </p>
<p>所有的常规文件、目录、符号链接和特殊文件都有一个唯一的inode。</p>
<p>The regular file inodes hold references to objects on OSTs that store the file data instead of references to the actual file data itself. </p>
<p>常规文件inode保存对存储文件数据的OST上对象的引用，而不是对实际文件数据本身的引用。</p>
<p>Object Storage Targets handle all of the interaction between client data requests and the underlying physical storage. </p>
<p>对象存储目标处理客户端数据请求和底层物理存储之间的所有交互。</p>
]]></content>
      <categories>
        <category>阅读笔记</category>
        <category>论文</category>
      </categories>
      <tags>
        <tag>Lustre</tag>
        <tag>分布式存储</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub Pages + Hexo + NexT 个人博客搭建</title>
    <url>/2021/03/06/gitpage-hexo-next%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>这篇文章将分享一个从零开始的自建个人博客网站的过程。</p>
<span id="more"></span>

<h1 id="开始前的一些话"><a href="#开始前的一些话" class="headerlink" title="开始前的一些话"></a>开始前的一些话</h1><h2 id="为什么要建个人博客？"><a href="#为什么要建个人博客？" class="headerlink" title="为什么要建个人博客？"></a>为什么要建个人博客？</h2><p>让自己养成写博客的好习惯。</p>
<p>记录一下自己的学习过程。</p>
<h2 id="为什么选择自建"><a href="#为什么选择自建" class="headerlink" title="为什么选择自建?"></a>为什么选择自建?</h2><p>市面上虽然已经有了像简书、 CSND 、博客园等成熟的内容创作平台，但是我还是选择了自建个人博客。主要原因在于那些平台广告繁杂、还有太多我用不到的功能，每次我看到了都感到很厌烦。</p>
<p>我的要求很简单：方便写作、方便查找、看着舒服。</p>
<p>因此我选择自建博客，仅加入我自己需要的功能，一切从简。</p>
<h2 id="为什么选择这套技术方案？"><a href="#为什么选择这套技术方案？" class="headerlink" title="为什么选择这套技术方案？"></a>为什么选择这套技术方案？</h2><p>GitHub Pages 技术平台， Hexo 博客框架， NexT 主题。</p>
<h3 id="为什么是-GitHub-Pages-？"><a href="#为什么是-GitHub-Pages-？" class="headerlink" title="为什么是 GitHub Pages ？"></a>为什么是 GitHub Pages ？</h3><p><strong>免费</strong>、<strong>轻量级</strong>、<strong>支持 Markdown</strong></p>
<p>GitHub Pages 可以免费使用，可以直接在上面部署，不需要自己去租用一台服务器。</p>
<p>我本人习惯在本地用 Markdown 写一些记录，因此 GitHub Pages 恰好符合我的需求。</p>
<h3 id="为什么是-Hexo-？"><a href="#为什么是-Hexo-？" class="headerlink" title="为什么是 Hexo ？"></a>为什么是 Hexo ？</h3><p>正如 Hexo 官网所介绍的， Hexo 是一个快速、简洁且高效的博客框架，高度符合我的需求。</p>
<h3 id="为什么是NexT？"><a href="#为什么是NexT？" class="headerlink" title="为什么是NexT？"></a>为什么是NexT？</h3><p>主题这种东西就是仁者见仁智者见智的了。 NexT 精致简约，符合我的审美。</p>
<h1 id="从零开始"><a href="#从零开始" class="headerlink" title="从零开始"></a>从零开始</h1><h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><h3 id="注册-GitHub-账号"><a href="#注册-GitHub-账号" class="headerlink" title="注册 GitHub 账号"></a>注册 GitHub 账号</h3><p>想要使用 GitHub Pages ，首先当然是要得有一个 GitHub 账号了。</p>
<p>如果没有账号可以登录 <a href="https://github.com/">GitHub</a> ，点击 Sign up ，注册一个新的账号。</p>
<p><img src="/2021-03-06-gitpage-hexo-next%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210306155928881.png" alt="GitHub注册界面"></p>
<h3 id="创建-GitHub-Pages"><a href="#创建-GitHub-Pages" class="headerlink" title="创建 GitHub Pages"></a>创建 GitHub Pages</h3><p>1.登录自己的 GitHub 账号。</p>
<p>2.创建一个新的公开的仓库，将其命名为 <em>username.github.io</em> ，这里的 username 是你的用户名。（如果命名不符合上述规则，则无法正确部署）。</p>
<p>3.通过 <em>username.github.io</em> 就可以访问你的网站了。</p>
<p>详细信息可以访问<a href="https://pages.github.com/">GitHub Pages</a>。</p>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>根据<a href="https://hexo.io/zh-cn/docs/">Hexo文档</a>配置环境并安装Hexo。</p>
<h3 id="本地建站"><a href="#本地建站" class="headerlink" title="本地建站"></a>本地建站</h3><p>根据<a href="https://hexo.io/zh-cn/docs/setup">Hexo建站文档</a>在本地建站。</p>
<h2 id="NexT"><a href="#NexT" class="headerlink" title="NexT"></a>NexT</h2><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="文章中插入图片"><a href="#文章中插入图片" class="headerlink" title="文章中插入图片"></a>文章中插入图片</h3><h3 id="文章中插入数学公式"><a href="#文章中插入数学公式" class="headerlink" title="文章中插入数学公式"></a>文章中插入数学公式</h3><p>在使用Typora的过程中发现在本地通过<code>$$</code>插入的 Latex 公式无法在网页端正常显示，可以通过以下方式解决。</p>
<p>①编辑 <strong>主题配置文件</strong>（*/themes/next/_config.yml*）， 将 <code>mathjax</code> 下的 <code>enable</code> 设定为 <code>true</code> 。</p>
<p>②在文章的<code>Front-matter</code>中加入<code>mathjax: true</code>。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;[LeetCode]21.合并两个有序链表&quot;</span><br><span class="line">date: 2021-03-08 18:46:16</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>完成上述配置即可在网页端正常显示 Latex 公式。</p>
]]></content>
      <categories>
        <category>技术分享</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>GitHub Page</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo部署中Spawn failed报错及其解决方案</title>
    <url>/2021/03/08/Hexo-Spawn-failed%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>本文将介绍 Hexo 在部署过程中出现 <code>Spawn failed</code> 报错的原因以及解决方法。</p>
<span id="more"></span>



<p>近期在将本地博客部署至 GitHub 上时遇到了 <code>Spawn failed</code> 报错，经过资料搜索发现了报错产生的原因以及解决方法。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在使用 <code>hexo deploy</code> 命令将博客部署到 <code>GitHub</code> 上时遇到了 <code>Spawn failed</code> 的报错，报错形式如下图所示。</p>
<p><img src="/2021/03/08/Hexo-Spawn-failed%E6%8A%A5%E9%94%99/spawn.png" alt="spawn"></p>
<h1 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h1><p>在本地任务目录下有一个 <code>.deploy_git</code> 文件夹，这个文件夹是本地 git 仓库，<code>hexo deploy</code> 命令就是将这个文件夹的内容 push 到 GitHub 上部署的。</p>
<p>本人是在部署过程中由于网络问题导致出现本地 git 仓库完成更新，但是在 GitHub 上的远程仓库更新并未完成的情况。此后本地 git 版本号与 GitHub 上版本号不一致导致此报错发生。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>只需要将本地仓库版本回滚到和 GitHub 仓库版本一致即可。</p>
<h2 id="①查看-GitHub-仓库版本"><a href="#①查看-GitHub-仓库版本" class="headerlink" title="①查看 GitHub 仓库版本"></a>①查看 GitHub 仓库版本</h2><p><img src="/2021/03/08/Hexo-Spawn-failed%E6%8A%A5%E9%94%99/image-20210308233033569.png" alt="image-20210308233033569"></p>
<h2 id="②查看本地仓库版本"><a href="#②查看本地仓库版本" class="headerlink" title="②查看本地仓库版本"></a>②查看本地仓库版本</h2><p>本地仓库版本更变信息可以在 <code>.deploy_git/.git/logs/HEAD</code>中查看。</p>
<p>例如我本地最后一次成功更新的信息如下所示，可以通过时间以及版本号来查看是否与 GitHub 仓库相同。</p>
<p><img src="/2021/03/08/Hexo-Spawn-failed%E6%8A%A5%E9%94%99/image-20210308233451795.png" alt="image-20210308233451795"></p>
<p>在此条记录后的所有提交信息在远程仓库上都是失败的。</p>
<p>此后由于本地版本和远程仓库版本不同，导致此后所有的提交操作均失败。</p>
<h2 id="③本地仓库回滚"><a href="#③本地仓库回滚" class="headerlink" title="③本地仓库回滚"></a>③本地仓库回滚</h2><p>为了使得本地仓库与远程仓库版本保持一致，我们只需通过以下命令将本地仓库回滚即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard commitId</span><br><span class="line"><span class="meta">#</span><span class="bash"> commitId 为需要回滚到的版本号</span></span><br></pre></td></tr></table></figure>

<h2 id="④重新部署"><a href="#④重新部署" class="headerlink" title="④重新部署"></a>④重新部署</h2><p>重新执行命令 <code>hexo deploy</code> 部署博客，即可解决问题。</p>
<p>本文参考：<a href="https://perry96.com/archives/882898e3.html">https://perry96.com/archives/882898e3.html</a></p>
]]></content>
      <categories>
        <category>技术分享</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]21.合并两个有序链表</title>
    <url>/2021/03/08/leetcode21/</url>
    <content><![CDATA[<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<p><img src="/2021/03/08/leetcode21/merge_ex1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
<p><strong>代码格式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">https://leetcode-cn.com/problems/merge-two-sorted-lists</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题是一个很简单的两个数组合并的操作。</p>
<p>数组合并典型的应用是在<strong>归并排序</strong>中的合并过程（merge），不过一般不在链表上进行归并排序。</p>
<p>合并两个链表可以采用递归或者迭代的方式。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>当两个链表不为空时，我们可以递归地定义两个链表合并（merge）的操作。</p>
<p>如果<code>l1[0] &lt; l2[0]</code>，则<code>l = l1[0] + merge(l1[1:], l2)</code>。否则<code>l = l2[0] + merge(l1, l2[1:])</code></p>
<p>如果两个链表任意一个为空，则将另一链表的后半段接到新的链表后端即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：$O(m+n)$</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>新建一个链表，并且设定一个哨兵节点。当两个链表不为空时，我们将值小的链表接入哨兵节点后面，哨兵节点向后移动一个，被接入的链表头向后移动一个，直到某个链表为空。最后将剩余节点接到哨兵节点之后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode l = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode temp = l;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                temp.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> l.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：$O(m+n)$</p>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
        <category>链表</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>递归</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]11.盛最多水的容器</title>
    <url>/2021/03/08/leetcode11/</url>
    <content><![CDATA[<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h1><p>给你 <code>n</code> 个非负整数 <code>a1，a2，...，an</code>，每个数代表坐标中的一个点 <code>(i, ai) </code>。在坐标内画 <code>n </code> 条垂直线，垂直线 i 的两个端点分别为 <code>(i, ai)</code> 和 <code>(i, 0)</code> 。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<span id="more"></span>

<p>说明：你不能倾斜容器。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2021/03/08/leetcode11/question_11.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：height &#x3D; [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：height &#x3D; [4,3,2,1,4]</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：height &#x3D; [1,2,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n = height.length</code></li>
<li><code>2 &lt;= n &lt;= 3 * 104</code></li>
<li><code>0 &lt;= height[i] &lt;= 3 * 104</code></li>
</ul>
<p><strong>代码格式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water">https://leetcode-cn.com/problems/container-with-most-water</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><p>此题很容易想到暴力求解的方法，用双重循环遍历计算出所有情况下（$C_n^2$种）容纳的水量，从中找到最大值即为所求。</p>
<p>时间复杂度：$O(n^2)$</p>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>首先我们设定两个指针<code>left</code>、<code>right</code>，分别指向坐标轴最左边和最右边，可以算出当前容器可以容纳的水为<code>min(height[left], height[right])*(right - left)</code>。</p>
<p>接下来我们只要不断将高度较低的一边（两边相同的情况下随机选择一边）的指针向里移动一个坐标，计算移动后的容器可以容纳的水，直到左右两个指针相邻。这个过程中，容纳的水最多的情况即为所求。</p>
<p>我们可以利用证明上述做法的正确性。</p>
<p>假设当前<code>height[left] &lt;= height[right]</code>，当前计算得到的容量为<code>height[left]*(right - left)</code>。</p>
<p>我们可以证明如果我们不移动左指针，无论如何移动右指针，得到的新容器的容量一定小于当前容器。若我们向左移动右指针得到一个新的右指针<code>newright</code>，一定有<code>newright &lt; right</code>，可得<code>newright - left &lt; right - left</code>。又因为可以容纳水的高度是由短的一边决定，所以移动右指针后得到的新容器可容纳的水的高度为<code>height = min(height[left], height[newright])</code>，可得<code>height &lt;= height[left]</code>。因此无论如何移动右指针，新得到的容器可容纳的水量一定小于当前容量。</p>
<p>我们将左指针向右移动一个坐标，即排除上述情况。同理，上述左右互换也成立。</p>
<p>因此上述的每次移动指针，排除的都是无效的情况。因此从两端在移动左右指针至相邻的情况下，一定能找到最大容量的一种情况。</p>
<p>时间复杂度：$O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> area = Math.min(height[left], height[right]) * (right - left);</span><br><span class="line">        <span class="keyword">while</span> (left != right - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = Math.min(height[left], height[right]) * (right - left);</span><br><span class="line">            area = Math.max(temp, area);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>LeetCode刷题</category>
        <category>中等</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
</search>
